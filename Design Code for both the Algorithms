// Left Shift Algorithm Desgin Code

module Left_Shift_Algo (
    input  wire [7:0] a, x, 
    output reg  [15:0] p 
);

    integer i;
    always @(*) begin
        p = 16'd0; 
        
        for (i = 7; i >= 0; i = i - 1)
            p = (p << 1) + (x[i] ? {8'b0, a} : 16'b0);
    end

endmodule


// Right Shift Algorithm Design Code

module Right_Algo #(
    parameter K = 8
)(
    input  wire           clk,
    input  wire           rst,
    input  wire           start,
    input  wire [K-1:0]   multiplicand,
    input  wire [K-1:0]   multiplier,
    output reg [2*K-1:0]  product,
    output reg            done
);

    reg [K:0]   A;            // Accumulator
    reg [K-1:0] Q;            // Multiplier
    reg [K-1:0] M;            // Multiplicand
    reg [$clog2(K):0] count;

    reg [K:0] A_next;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            A       <= 0;
            Q       <= 0;
            M       <= 0;
            count   <= 0;
            product <= 0;
            done    <= 0;
        end
        else begin
            if (start) begin
                // Load initial values
                A     <= 0;
                Q     <= multiplier;
                M     <= multiplicand;
                count <= K;
                done  <= 0;
            end
            else if (count != 0) begin
                // Conditional add
                if (Q[0])
                    A_next = A + M;
                else
                    A_next = A;

                // Right shift combined register
                {A, Q} <= {A_next, Q} >> 1;

                count <= count - 1;
            end
            else if (!done) begin
                product <= {A, Q};
                done <= 1;
            end
        end
    end

endmodule
